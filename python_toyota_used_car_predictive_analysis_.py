# -*- coding: utf-8 -*-
"""Toyota used car predictive analysis .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sY963ssE49YJl2wxdee4ObVP0WGJTmbB

# **Prediksi Harga Mobil Bekas (Used Car)**

* Nama : Annisa Dewiyanti
* ID Dicoding : andwynt
* Dataset: https://www.kaggle.com/datasets/adityadesai13/used-car-dataset-ford-and-mercedes
* Domain : bisnis otomotif

# Business Understanding

Pasar mobil bekas merupakan salah satu sektor industri otomotif yang terus berkembang, terutama karena faktor harga yang lebih terjangkau dibanding mobil baru. Dealer mobil, perusahaan pembiayaan, serta platform online penjualan mobil membutuhkan pemahaman yang baik terhadap faktor-faktor apa saja yang mempengaruhi harga jual mobil bekas agar dapat mengambil keputusan yang lebih akurat, seperti penetapan harga jual, prediksi permintaan, hingga strategi pemasaran.

Dataset ini berisi data mobil bekas dengan merek **Toyota** , termasuk informasi seperti model, tahun, jenis bahan bakar, transmisi, jarak tempuh, dan harga jual. Informasi ini sangat relevan untuk menganalisis faktor-faktor yang memengaruhi harga mobil bekas dan mengembangkan model prediksi harga.

# 1. Data Understanding

#### Setup Import Libraries
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
# %matplotlib inline
import seaborn as sns
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import OneHotEncoder
from sklearn.decomposition import PCA
import numpy as np
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error
from sklearn.ensemble import RandomForestRegressor
from sklearn.ensemble import AdaBoostRegressor

!pip install gdown

"""#### Loading dataset"""

# download dataset dari google drive https://drive.google.com/file/d/1Y5mDD3dyIbgCynfRKL4l5WtRdtLhuyyn/view?usp=drive_link
!gdown --id 1Y5mDD3dyIbgCynfRKL4l5WtRdtLhuyyn

"""#### Menampilkan Isi Dataset"""

car = pd.read_csv('toyota.csv')
car.head()

"""Pada dataset Toyota.csv terdapat variabel:

* model -> macam-macam series pada mobil Toyota.
* year -> tahun model mobil diproduksi.
* price -> harga mobil (satuan dollar / $).
* transmission -> transmission pada. mobil (Automatic, Manual, Semi-Auto)
* mileage -> jarak tempuh yang dapat dilalui mobil.
* fuelType -> tipe bahan bakar mobil (Petrol, Diesel, Hybrid, Electric, dll).
* tax -> pajak tahunan.
* mpg -> efesiensi bahan bakar.
* engineSize -> kapasistas mesin pada mobil.
"""

car.describe()

car.info()

"""terdapat 6 data **numerik** yakni: year, price, mileage, tax, mpg, dan engineSize lalu 3 data **kategoris** yakni: model, transmission, dan fuelType.

#### Menangani Missing Values
"""

car.isnull().sum()

mileage =(car.mileage == 0).sum()
mpg =(car.mpg == 0).sum()
engineSize =(car.engineSize == 0).sum()


print('jumlah nilai 0 pada kolom mileage : ', mileage)
print('jumlah nilai 0 pada kolom mpg : ', mpg)
print('jumlah nilai 0 pada kolom engineSize: ', engineSize)

"""Setelah dilakukan pengecekan terdapat 6 data yang bernilai 0 pada engineSize. Selanjutnya, mengecek jumlah cek apakah data bernilai 0 pada salah satu dimensi terdapat pada dimensi lain."""

car.loc[car['engineSize']==0]

car = car.loc[(car[['mileage','tax','mpg','engineSize']]!=0).all(axis=1)]
car.shape

"""Kemudian, menghapus baris data pada kolom mileage, tax, mpg, engineSize yang bernilai 0."""

car.describe()

"""#### Menangani outliers"""

numeric = ['year','price','mileage','tax','mpg','engineSize']
categorical= ['model','transmission','fuelType']

"""* Visualisasi bloxplot untuk column tax"""

sns.boxplot(x=car['tax'])

"""* Visualisasi bloxplot untuk column mileage"""

sns.boxplot(x=car['mileage'])

"""* Visualisasi bloxplot untuk column mpg"""

sns.boxplot(x=car['mpg'])

"""* Visualisasi bloxplot untuk column engineSize"""

sns.boxplot(x=car['engineSize'])

# Select only numeric columns for outlier removal
numeric_cols = car.select_dtypes(include=np.number)

Q1 = numeric_cols.quantile(0.25)
Q3 = numeric_cols.quantile(0.75)
IQR = Q3-Q1

# Filter outliers based on numeric columns
car = car[~((numeric_cols < (Q1 - 1.5 * IQR)) | (numeric_cols > (Q3 + 1.5 * IQR))).any(axis=1)]

car.shape

plt.subplots(figsize=(10,7))
sns.boxplot(data=car).set_title("Toyota Car")
plt.show()

"""Penghapusan outlier telah membuat distribusi data, seperti price, mileage, tax, dan enginesize mobil Toyota, menjadi lebih fokus dan terpusat. Hal ini menghasilkan representasi yang lebih akurat mengenai karakteristik mayoritas data, memungkinkan analisis yang lebih relevan dan model statistik yang lebih robust, meskipun perlu diingat potensi kehilangan informasi dari kasus-kasus ekstrem.

# Exploratory Data Analysis

* Fitur Model
"""

feature = categorical[0]
count = car[feature].value_counts()
percent = 100*car[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature)

"""* Fitur Transmission"""

feature = categorical[1]
count = car[feature].value_counts()
percent = 100*car[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature)

"""* Fitur Engine Type

"""

feature = categorical[2]
count = car[feature].value_counts()
percent = 100*car[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature)

"""melihat histogram masing-masing fitur **numerikal** yaitu year, price, mileage, tax, mpg dan engineSize"""

car.hist(bins=50, figsize=(20,15))
plt.show()

"""* Multivariate Analysis

1. Mengecek rata-rata price terhadap masing-masing fitur untuk mengetahui pengaruh fitur terhadap price
"""

kategori_features = car.select_dtypes(include='object').columns.to_list()
for col in kategori_features:
    sns.catplot(x=col, y='price', kind='bar', dodge=False, height = 7, aspect= 3, data=car, palette='Set1')
    plt.title('Rata-rata "price" relatif terhadap - {}'.format(col))

"""**insight**

Diagram 1 – Harga vs Model:
Model mobil sangat mempengaruhi harga. Model seperti Canny dan PROACE VERSO memiliki harga tertinggi, sementara Aygo menjadi yang paling terjangkau. Model merupakan indikator kuat dalam menentukan harga mobil.

Diagram 2 – Harga vs Transmisi:
Mobil dengan transmisi Automatic memiliki harga rata-rata lebih tinggi dibanding Manual dan Semi-Auto, menandakan kemungkinan preferensi pengguna atau biaya teknologi yang lebih mahal.

Diagram 3 – Harga vs Jenis Bahan Bakar:
Mobil Hybrid memiliki harga tertinggi, diikuti oleh Diesel dan Petrol. Ini mencerminkan nilai tambah dari teknologi ramah lingkungan dan efisiensi bahan bakar.

***Kesimpulan akhir, fitur kategori memiliki pengaruh yang tinggi terhadap harga.***

2. mengobservasi korelasi antara fitur numerik dalam dataset
"""

sns.pairplot(car, diag_kind='kde')

"""**insight**

Harga mobil cenderung lebih tinggi pada mobil yang lebih baru (year) dan lebih rendah jika jarak tempuhnya tinggi (mileage). Dua fitur ini paling kuat memengaruhi harga.
"""

plt.figure(figsize=(10,8))
numeric_car = car.select_dtypes(include=np.number)
correlation_matrics = numeric_car.corr().round(2)

sns.heatmap(data=correlation_matrics, annot=True, cmap='coolwarm', linewidths=0.5)
plt.title('correlation Matrix untuk fitur Numerik', size=20)
plt.show()

"""**insight**

* **engineSize** memiliki korelasi paling kuat dengan price (0.75) → semakin besar ukuran mesin, semakin mahal harga mobil.

* **year** juga berkorelasi positif dengan harga (0.32) → mobil lebih baru cenderung lebih mahal.

* **mileage** berkorelasi negatif kuat dengan year (-0.65) → mobil lama biasanya punya jarak tempuh lebih tinggi.

* Korelasi negatif moderat antara **tax** dan **price** (-0.49) → kemungkinan mobil murah dikenai pajak lebih tinggi pada dataset ini.

**Kesimpulan**:

Harga mobil paling dipengaruhi oleh engineSize, year, dan tax.

# Data Preparation

* Menggunakan oneHotEncoder
"""

car = pd.concat([car, pd.get_dummies(car['model'], prefix='model', drop_first=True)], axis=1)
car = pd.concat([car, pd.get_dummies(car['transmission'], prefix='transmission', drop_first=True)], axis=1)
car = pd.concat([car, pd.get_dummies(car['fuelType'], prefix='fuelType', drop_first=True)], axis=1)
car.drop(['model','transmission','fuelType'], axis=1, inplace=True)
car.head()

"""* reduksi dimensi PCA"""

sns.pairplot(car[['engineSize','tax']], plot_kws={'s':2})

"""* Aplikasikan class PCA"""

pca = PCA(n_components=2, random_state=123)
pca.fit(car[['engineSize','tax']])
princ_comp = pca.transform(car[['engineSize','tax']])

pca.explained_variance_ratio_.round(3)

# membuat fitur bernama 'fitur'

pca = PCA(n_components=1, random_state=123)
pca.fit(car[['engineSize','tax']])
car['fitur'] = pca.transform(car.loc[:, ('engineSize','tax')]).flatten()
car.drop(['engineSize','tax'], axis=1, inplace=True)

"""* Data Splitting"""

# Membagi data latih dan data uji

X = car.drop(['price'], axis=1)
y = car['price']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, random_state=123)

print(f'Total # of sample in whole dataset: {len(X)}')
print(f'Total # of sample in train dataset: {len(X_train)}')
print(f'Total # of sample in test dataset: {len(X_test)}')

# Standarize

numerik = ['year','fitur']
scaler = StandardScaler()
scaler.fit(X_train[numerik])
X_train[numerik] = scaler.transform(X_train.loc[:, numerik])
X_train[numerik].head()

# mean

X_train[numerik].describe().round(4)

"""# Model Development

menggunakan gabungan tiga model algoritma yang akan digunakan yaitu K-Nearest Neighbor (KNN), Random Forest, dan Boosting Algorithm. Kemudian, mencari performa yang paling baik dari ketiga algoritma tersebut.

*  menyiapkan dataframe
"""

models = pd.DataFrame(index=['train_mse','test_mse'],
                    columns=['KNN', 'RandomForest', 'Boosting'])

"""* K-Nearest Neighbors"""

knn = KNeighborsRegressor(n_neighbors=10)
knn.fit(X_train, y_train)
y_pred_knn = knn.predict(X_train)

"""* boosting Algorithm"""

boosting = AdaBoostRegressor(n_estimators=50, learning_rate=0.05, random_state=55)
boosting.fit(X_train, y_train)
models.loc['train_mse','Boosting'] = mean_squared_error(y_pred=boosting.predict(X_train), y_true=y_train)
X_test.loc[:, numerik] = scaler.transform(X_test[numerik])

"""* Random Forest"""

RF = RandomForestRegressor(n_estimators=45, max_depth=16, random_state=55, n_jobs=-1)
RF.fit(X_train, y_train)

models.loc['train_mse','RandomForest'] = mean_squared_error(y_pred=RF.predict(X_train), y_true=y_train)

"""# Evaluasi Model

* Evaluasi ketiga model dengan matrix mse
"""

mse = pd.DataFrame(columns=['train','test'],index=['KNN','RF','boosting'])
model_dict = {'KNN':knn, 'RF':RF, 'boosting': boosting}
for name, model in model_dict.items():
    mse.loc[name, 'train'] = mean_squared_error(y_true=y_train, y_pred=model.predict(X_train))/1e3
    mse.loc[name, 'test'] = mean_squared_error(y_true=y_test, y_pred=model.predict(X_test))/1e3
mse

#menampilkan plot metrix dengan bar chart

fig, ax = plt.subplots()
mse.sort_values(by='test', ascending=False).plot(kind='barh', ax=ax, zorder=3)
ax.grid(zorder=0)

"""**insight:**

Dari gambar diatas memperlihatkan bahwa RF memberikan nilai error yang paling kecil. maka model RF dipilih sebagai model terbaik untuk melakukan prediksi harga mobil toyota bekas

#Nilai Akurasi Model
"""

knn_accuracy = knn.score(X_test, y_test)*100
rf_accuracy = RF.score(X_test, y_test)*100
boosting_accuracy = boosting.score(X_test, y_test)*100

list_evaluasi = [[knn_accuracy],
            [rf_accuracy],
            [boosting_accuracy]]
evaluasi = pd.DataFrame(list_evaluasi,
                        columns=['Accuracy (%)'],
                        index=['K-Nearest Neighbor', 'Random Forest', 'Boosting'])
evaluasi

"""Dari hasil evaluasi di atas dapat memberikan informasi bahwa model Algorithma Random Forest mencapai akurasi hingga 94% lebih, model Bossting 89% lebih, sedangkan model KNN masih termasuk rendah yakni -13%

# Prediksi
"""

prediksi = X_test.iloc[:1].copy()
pred_dict = {'y_true':y_test[:1]}
for name, model in model_dict.items():
    pred_dict['prediksi_'+name] = model.predict(prediksi).round(1)

pd.DataFrame(pred_dict)

"""dapat dilihat dari prediksi di atas bahwa prediki dengan model RF(Rain Forest) memberikan hasil yang paling mendekati nilai y_true dibanding dengan kedua model lainnya.

---------------------------------------------------------------------------------
"""